#include "tcpopt.h"
#include <assert.h>

const char *type_name[] = {
  " ",
  "No Operation",
  "Maximum Segment Size",
  "Window Scale",
  "SACK Permitted",
  "SACK",
  " ",
  " ",
  "Timestamp"
};

/**
 * @brief Get the name of the type in string
 * @param type the type of the TCP option
 * @return the type name
 */
const char *get_type_name(int type)
{
  assert(type > 0);
  return type_name[type];
}

/**
 * @brief Get the value from the string
 * @param p the pointer to the first byte of the string
 * @param len the length of the string
 * @return the value
 */
int get_value(void **val, int type, uint8_t *p, int len)
{
  debug("Start: get_value(): val: %p, type: %d, p: %p, len: %d", val, type, p, len);
  assert(p != NULL);
  assert(len >= 0);

  int i;
  uint32_t *ret;
  struct block_st *prev, *curr;
  struct sack_st *sptr;
  struct timestamp_st *tptr;
  prev = NULL;
  curr = NULL;
  sptr = NULL;
  tptr = NULL;

  switch (type)
  {
    case TCPOPT_NO_OPERATION:
    case TCPOPT_SACK_PERMITTED:
      debug("Type: %s", get_type_name(type));
      break;
    case TCPOPT_MSS:
    case TCPOPT_WINDOW_SCALE:
      ret = (uint32_t *)malloc(sizeof(uint32_t));
      *ret = 0;
      for (i=0; i<len; i++)
      {
        *ret = (*ret << 8) | p[i];
      }
      *val = ret;
      break;
    case TCPOPT_SACK:
      if (len % 8 != 0) 
      {
        debug("Length error in TCPOPT_SACK");
        goto err;
      }
      sptr = (struct sack_st *)malloc(sizeof(struct sack_st));
      memset(sptr, 0x0, sizeof(struct sack_st));
      prev = sptr->head;

      while (len > 0)
      {
        curr = (struct block_st *)malloc(sizeof(struct block_st));
        memset(curr, 0x0, sizeof(struct block_st));
        PTR_TO_VAL_4BYTES(p, curr->left);
        PTR_TO_VAL_4BYTES(p, curr->right);
        prev->next = curr;
        prev = curr;
        len -= 8;
      }
      *val = sptr;
      break;
    case TCPOPT_TIMESTAMP:
      if (len != 8)
      {
        debug("Length error in TCPOPT_TIMESTAMP");
        goto err;
      }
      assert(tptr == NULL);
      tptr = (struct timestamp_st *)malloc(sizeof(struct timestamp_st));
      memset(tptr, 0x0, sizeof(struct timestamp_st));
      PTR_TO_VAL_4BYTES(p, tptr->ts);
      PTR_TO_VAL_4BYTES(p, tptr->echo_reply);
      *val = tptr;
      break;
  }
  debug("Finish: get_value()");
  return SUCCESS;
err:
  debug("Finish: get_value()");
  return FAILURE;
}

/**
 * @brief Initialize the tcp option block (struct tcpopt_st, defined in tcpopt.h)
 * @return the intialized tcp option block
 */
struct tcpopt_st *init_tcpopt_block(void)
{
  struct tcpopt_st *ret;
  ret = (struct tcpopt_st *)malloc(sizeof(struct tcpopt_st));
  memset(ret, 0x0, sizeof(struct tcpopt_st));
  return ret;
}

void free_value(struct tcpopt_st *blk)
{
  uint32_t *ret;
  struct sack_st *sptr;
  struct block_st *prev, *curr;
  struct timestamp_st *tptr;

  switch(blk->type)
  {
    case TCPOPT_NO_OPERATION:
    case TCPOPT_SACK_PERMITTED:
      break;
    case TCPOPT_MSS:
    case TCPOPT_WINDOW_SCALE:
      ret = (uint32_t *)(blk->val);
      free(ret);
      break;
    case TCPOPT_SACK:
      sptr = (struct sack_st *)(blk->val);
      curr = sptr->head;
      while (curr)
      {
        prev = curr;
        curr = curr->next;
        free(prev);
      }
      free(sptr);
      break;
    case TCPOPT_TIMESTAMP:
      tptr = (struct timestamp_st *)(blk->val);
      free(tptr);
      break;
  }
  blk->val = NULL;
}

/**
 * @brief Free the tcp option block
 * @param blk the tcp option block to be freed
 */
void free_tcpopt_block(struct tcpopt_st *blk)
{
  if (blk)
  {
    free_value(blk);
    blk->type = 0;
    blk->next = NULL;
    free(blk);
    blk = NULL;
  }
}

/**
 * @brief Parse the tcp options from the tcp header
 * @param tcph the tcp header
 * @return the pointer to the list of the tcp options
 */
struct tcpopt_st *get_tcpopt_blocks(struct tcphdr *tcph)
{
  assert(tcph != NULL);
  int idx, optlen, len, ret;
  struct tcpopt_st *head, *prev, *ptr;
  uint8_t *opt;

  head = prev = ptr = NULL;
  optlen = tcph->doff * 4 - 20;
  opt = (uint8_t *)tcph + 20;
  idx = 0;

  while (idx < optlen)
  {
    ptr = init_tcpopt_block();
    ptr->type = opt[idx++];

    if (ptr->type != TCPOPT_NO_OPERATION)
      len = opt[idx++];
    else
      len = 0;

    // Note that the len include the length of the type and the length fields
    if (len > 2)
    {
      ret = get_value(&(ptr->val), ptr->type, opt + idx, len - 2);
      assert(ret == SUCCESS);
      idx += len - 2;
    }

    if (prev)
    {
      prev->next = ptr;
      prev = ptr;
    }

    if (!head)
    {
      head = prev = ptr;
    }
  }
  
  return head;
}

/**
 * @brief Free the tcp option blocks
 * @param head the pointer to the tcp option list
 */
void free_tcpopt_blocks(struct tcpopt_st *head)
{
  assert(head != NULL);

  struct tcpopt_st *curr, *next;
  next = NULL;
  curr = head;
  next = curr->next;

  while (next)
  {
    curr = next;
    next = curr->next;
    free_tcpopt_block(curr);
  }

  free_tcpopt_block(head);
  curr = NULL;
  next = NULL;
}

/**
 * @brief Find the specific block matched with the particular type
 * @param head the pointer to the tcp option list
 * @param type the tcp option type to be retrieved
 * @return the pointer to the target tcp option block
 */
struct tcpopt_st *find_block_by_type(struct tcpopt_st *head, int type)
{
  assert(head != NULL);
  assert(type > 0);

  struct tcpopt_st *ret, *curr;
  ret = NULL;
  curr = head;

  while (curr)
  {
    if (curr->type == type)
    {
      ret = curr;
      break;
    }
    curr = curr->next;
  }

  return ret;
}

/**
 * @brief Modify the value of the particular tcp option block, retrieved by the type
 * @param head the pointer to the tcp option list
 * @param type the tcp option type to be retrieved
 * @param val the value to be inserted
 * @return success/failure
 */
int modify_tcpopt_block(struct tcpopt_st *head, int type, void *val)
{
  struct tcpopt_st *blk;
  int included;
  blk = find_block_by_type(head, type);

  if (blk)
  {
    included = TRUE;
  }
  else
  {
    included = FALSE;
    blk = (struct tcpopt_st *)malloc(sizeof(struct tcpopt_st));
    blk->type = type;
  }
  blk->val = val;

  if (included == FALSE)
  {
    blk->next = head;
    head = blk;
  }

  return SUCCESS;
}

/**
 * @brief Print the tcp option list
 * @param head the pointer to the tcp option list
 */
void print_tcpopt_blocks(struct tcpopt_st *head)
{
  struct tcpopt_st *ptr;
  uint32_t *val;
  struct sack_st *sptr;
  struct block_st *bptr;
  struct timestamp_st *tptr;
  int cnt;

  ptr = head;

  while (ptr)
  {
    switch (ptr->type)
    {
      case TCPOPT_NO_OPERATION:
      case TCPOPT_SACK_PERMITTED:
        debug("Type: %s", get_type_name(ptr->type));
        break;
      case TCPOPT_MSS:
      case TCPOPT_WINDOW_SCALE:
        val = (uint32_t *)(ptr->val);
        debug("Type: %s / Value: %u\n", get_type_name(ptr->type), *val);
        break;
      case TCPOPT_SACK:
        sptr = (struct sack_st *)(ptr->val);
        bptr = sptr->head;
        debug("Type: %s / Num of Blocks: %u\n", get_type_name(ptr->type), sptr->num);
        cnt = 0;
        while (bptr)
        {
          debug("  %d> Left: %u / Right: %u", ++cnt, bptr->left, bptr->right);
          bptr = bptr->next;
        }
        break;
      case TCPOPT_TIMESTAMP:
        tptr = (struct timestamp_st *)(ptr->val);
        debug("Type: %s / Timestamp: %u / Echo Reply: %u\n", 
            get_type_name(ptr->type), tptr->ts, tptr->echo_reply);
        break;
      default:
        debug("Unknown Type");
    }
    ptr = ptr->next;
  }
}

/**
 * @brief Serialize the tcp options
 * @param head the pointer to the tcp option list
 * @param len the pointer to the length of the serialized tcp options
 * @return success/failure
 */
uint8_t *serialize_tcp_options(struct tcpopt_st *head, int *len)
{
  uint8_t *ret, *p;
  struct tcpopt_st *blk;
  struct sack_st *sptr;
  struct block_st *bptr;
  struct timestamp_st *tptr;

  ret = (uint8_t *)malloc(TCPOPT_MAX_SIZE);
  p = ret;
  blk = head;
  while (blk)
  {
    *(p++) = blk->type;
    switch(blk->type)
    {
      case TCPOPT_NO_OPERATION:
        break;
      case TCPOPT_MSS:
        *(p++) = 4;
        VAL_TO_PTR_2BYTES(*((uint32_t *)(blk->val)), p);
        break;
      case TCPOPT_WINDOW_SCALE:
        *(p++) = 3;
        *(p++) = *((uint32_t *)(blk->val));
        break;
      case TCPOPT_SACK_PERMITTED:
        *(p++) = 2;
        break;
      case TCPOPT_SACK:
        sptr = (struct sack_st *)(blk->val);
        *(p++) = sptr->num * 8 + 2;
        bptr = sptr->head;
        while(bptr)
        {
          VAL_TO_PTR_4BYTES(bptr->left, p);
          VAL_TO_PTR_4BYTES(bptr->right, p);
          bptr = bptr->next;
        }
        break;
      case TCPOPT_TIMESTAMP:
        tptr = (struct timestamp_st *)(blk->val);
        *(p++) = 10;
        VAL_TO_PTR_4BYTES(tptr->ts, p);
        VAL_TO_PTR_4BYTES(tptr->echo_reply, p);
        break;
    }
    blk = blk->next;
  }

  return ret;
}

/**
 * @brief Serialize the internal structure
 * @param iph IP header
 * @param tcph TCP header
 * @param head the pointer to the tcp option list
 * @return success/failure
 */
int serialize_tcphdr(struct iphdr *iph, struct tcphdr *tcph, struct tcpopt_st *head)
{
  assert(iph != NULL);
  assert(tcph != NULL);
  assert(head != NULL);

  int optlen, total, ihl, doff, plen, len, diff;
  uint8_t *init, *p, *opt;

  total = ntohs(iph->tot_len);
  ihl = iph->ihl * 4;
  doff = tcph->doff * 4;
  plen = total - ihl - doff;
  optlen = doff - 20;
  init = (uint8_t *)tcph;
  p = init + 20;

  debug("AS-IS: total: %u, ihl: %u, doff: %u, plen: %u, optlen: %u\n", 
      total, ihl, doff, plen, optlen);

  opt = serialize_tcp_options(head, &len);
  diff = optlen - len;
  memmove(init + doff + diff, init + doff, plen);
  memcpy(p, opt, len);
  free(opt);

  iph->tot_len = htons(total + diff);
  tcph->doff = (len + 20) / 4;

  total = ntohs(iph->tot_len);
  ihl = iph->ihl * 4;
  doff = tcph->doff * 4;
  plen = total - ihl - doff;
  optlen = doff - 20;

  debug("TO-BE: total: %u, ihl: %u, doff: %u, plen: %u, optlen: %u\n", 
      total, ihl, doff, plen, optlen);

  return SUCCESS;
}
